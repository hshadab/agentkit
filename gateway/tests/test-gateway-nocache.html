<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gateway Test - No Cache</title>
    <script src="./js/lib/ethers.umd.min.js"></script>
</head>
<body>
    <h1>Gateway Signature Test - Direct</h1>
    <button id="test-btn">Test Signature Generation</button>
    <pre id="output"></pre>
    
    <script>
        const output = document.getElementById('output');
        const log = (msg) => {
            output.textContent += msg + '\n';
            console.log(msg);
        };
        
        document.getElementById('test-btn').addEventListener('click', async () => {
            log('Testing signature generation...\n');
            
            const PRIVATE_KEY = 'c3d22f444c7fb8339d3b16ed642e5297059a694437d7effd22d55ea5e60dc9ab';
            const wallet = new ethers.Wallet(PRIVATE_KEY);
            
            log('Wallet: ' + wallet.address);
            
            const toBytes32 = (addr) => '0x' + addr.toLowerCase().replace('0x', '').padStart(64, '0');
            
            // EXACT structure that works in Node.js tests
            const domain = {
                name: 'GatewayWallet',
                version: '1'
            };
            
            const types = {
                BurnIntent: [
                    { name: 'maxBlockHeight', type: 'uint256' },
                    { name: 'maxFee', type: 'uint256' },
                    { name: 'spec', type: 'TransferSpec' }
                ],
                TransferSpec: [
                    { name: 'version', type: 'uint32' },
                    { name: 'sourceDomain', type: 'uint32' },
                    { name: 'destinationDomain', type: 'uint32' },
                    { name: 'sourceContract', type: 'bytes32' },
                    { name: 'destinationContract', type: 'bytes32' },
                    { name: 'sourceToken', type: 'bytes32' },
                    { name: 'destinationToken', type: 'bytes32' },
                    { name: 'sourceDepositor', type: 'bytes32' },
                    { name: 'destinationRecipient', type: 'bytes32' },
                    { name: 'sourceSigner', type: 'bytes32' },
                    { name: 'destinationCaller', type: 'bytes32' },
                    { name: 'value', type: 'uint256' },
                    { name: 'salt', type: 'bytes32' },
                    { name: 'hookData', type: 'bytes' }
                ]
            };
            
            const message = {
                maxBlockHeight: ethers.BigNumber.from('115792089237316195423570985008687907853269984665640564039457584007913129639935'),
                maxFee: ethers.BigNumber.from('2000001'),
                spec: {
                    version: 1,
                    sourceDomain: 0,
                    destinationDomain: 6,
                    sourceContract: toBytes32('0x0077777d7EBA4688BDeF3E311b846F25870A19B9'),
                    destinationContract: toBytes32('0x0022222ABE238Cc2C7Bb1f21003F0a260052475B'),
                    sourceToken: toBytes32('0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238'),
                    destinationToken: toBytes32('0x036CbD53842c5426634e7929541eC2318f3dCF7e'),
                    sourceDepositor: toBytes32(wallet.address),
                    destinationRecipient: toBytes32('0x742d35Cc6634C0532925a3b8D402b1DeF8d87d87'),
                    sourceSigner: toBytes32(wallet.address),
                    destinationCaller: toBytes32('0x0000000000000000000000000000000000000000'),
                    value: ethers.BigNumber.from('10000'),
                    salt: toBytes32('0x' + Date.now().toString(16)),
                    hookData: '0x'
                }
            };
            
            log('Signing...');
            const signature = await wallet._signTypedData(domain, types, message);
            log('Signature: ' + signature.substring(0, 40) + '...\n');
            
            const recovered = ethers.utils.verifyTypedData(domain, types, message, signature);
            log('Recovered: ' + recovered);
            log('Expected:  ' + wallet.address);
            log('Match: ' + (recovered.toLowerCase() === wallet.address.toLowerCase() ? '✅ YES' : '❌ NO'));
            
            // Test with Circle API
            log('\nTesting with Circle API...');
            const apiPayload = [{
                burnIntent: {
                    maxBlockHeight: message.maxBlockHeight.toString(),
                    maxFee: message.maxFee.toString(),
                    spec: {
                        version: message.spec.version,
                        sourceDomain: message.spec.sourceDomain,
                        destinationDomain: message.spec.destinationDomain,
                        sourceContract: message.spec.sourceContract,
                        destinationContract: message.spec.destinationContract,
                        sourceToken: message.spec.sourceToken,
                        destinationToken: message.spec.destinationToken,
                        sourceDepositor: message.spec.sourceDepositor,
                        destinationRecipient: message.spec.destinationRecipient,
                        sourceSigner: message.spec.sourceSigner,
                        destinationCaller: message.spec.destinationCaller,
                        value: message.spec.value.toString(),
                        salt: message.spec.salt,
                        hookData: message.spec.hookData
                    }
                },
                signature: signature
            }];
            
            try {
                const response = await fetch('https://gateway-api-testnet.circle.com/v1/transfer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'Authorization': 'Bearer SAND_API_KEY:3dc2c2b70ae5bd1943212a8521638b3b:8bb8eebdb457b04f261990e34c49d838'
                    },
                    body: JSON.stringify(apiPayload)
                });
                
                const result = await response.text();
                if (response.status === 201) {
                    log('✅ Circle API Success!');
                    const data = JSON.parse(result);
                    log('Transfer ID: ' + data.transferId);
                } else {
                    log('❌ Circle API Error: ' + response.status);
                    log(result);
                }
            } catch (error) {
                log('Error calling Circle API: ' + error.message);
            }
        });
    </script>
</body>
</html>